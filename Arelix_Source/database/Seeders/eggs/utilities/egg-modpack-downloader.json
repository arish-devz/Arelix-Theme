{
    "_comment": "DO NOT EDIT: FILE GENERATED AUTOMATICALLY BY PTERODACTYL PANEL - PTERODACTYL.IO",
    "meta": {
        "version": "PTDL_v2",
        "update_url": null
    },
    "exported_at": "2025-10-31T00:00:00+00:00",
    "name": "Modpack Downloader Arelix",
    "author": "arelixs@gmail.com",
    "description": "Downloads and extracts Minecraft modpacks from URLs. Extracts JAR files to /mods directory.",
    "features": [],
    "docker_images": {
        "Debian": "ghcr.io/pterodactyl/yolks:debian"
    },
    "file_denylist": [],
    "startup": "echo 'Modpack Downloader - Download completed during installation. No runtime server.'",
    "config": {
        "files": "{}",
        "startup": "{\r\n    \"done\": \"Modpack Downloader - Download completed\"\r\n}",
        "logs": "{}",
        "stop": "echo 'Stopping downloader (no-op)'"
    },
    "scripts": {
        "installation": {
            "script": "#!/bin/bash\n\n# Arelix Smart Modpack Installer (Python Based)\n# Integrated Arelix API Support\n# Target: Debian (ghcr.io/pterodactyl/installers:debian)\n\n# 1. Setup Environment\napt-get update && apt-get install -y python3 curl unzip\nmkdir -p /mnt/server\ncd /mnt/server || exit\n\n# 2. Embed Installer Script\ncat << 'PYTHON_EOF' > /tmp/installer.py\nimport json\nimport os\nimport shutil\nimport sys\nimport zipfile\nimport urllib.request\nimport urllib.error\nimport glob\nimport ssl\nimport subprocess\n\n# --- Configuration (Injected by Egg or ENV) ---\nMODPACK_URL = os.getenv(\"MODPACK_URL\", \"\")\nCURSEFORGE_API_KEY = os.getenv(\"CURSEFORGE_API_KEY\", \"$2a$10$Mq226KUCWWFalJoPKe25YuHzCIKUoQJGx8ejyqhOyO92bF2cdX2dm\")\nAPI_BASE_URL = \"https://api.arelix.tech/java/versions/builds\"\n\nENV_MC_VERSION = os.getenv(\"MINECRAFT_VERSION\", \"\")\nENV_LOADER = os.getenv(\"MODLOADER\", \"\")\n# ----------------------------------------------\n\n# Ignore SSL errors for broad compatibility in restricted containers\nctx = ssl.create_default_context()\nctx.check_hostname = False\nctx.verify_mode = ssl.CERT_NONE\n\ndef log(msg):\n    print(f\"[SmartInstaller] {msg}\", flush=True)\n\ndef download_file(url, target_path):\n    log(f\"Downloading {url} -> {target_path}\")\n    try:\n        req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})\n        with urllib.request.urlopen(req, context=ctx) as response, open(target_path, 'wb') as out_file:\n            shutil.copyfileobj(response, out_file)\n    except Exception as e:\n        log(f\"Error downloading {url}: {e}\")\n        return False\n    return True\n\n# --- API & Server JAR Logic ---\ndef process_installation_steps(installation_data, extract_dir):\n    log(\"Processing server installation steps...\")\n    for step_group in installation_data:\n        for step in step_group:\n            s_type = step.get('type')\n            if s_type == 'download':\n                url = step.get('url')\n                file_name = step.get('file')\n                if not url or not file_name: continue\n                target = os.path.join(extract_dir, file_name)\n                os.makedirs(os.path.dirname(target), exist_ok=True)\n                log(f\"  - Downloading {file_name}\")\n                download_file(url, target)\n            elif s_type == 'unzip':\n                file_name = step.get('file')\n                location = step.get('location', '.')\n                zip_path = os.path.join(extract_dir, file_name)\n                if not os.path.exists(zip_path):\n                    log(f\"  - Error: Zip {file_name} not found to unzip.\")\n                    continue\n                log(f\"  - Unzipping {file_name}\")\n                try:\n                    extract_target = extract_dir if location == '.' else os.path.join(extract_dir, location)\n                    os.makedirs(extract_target, exist_ok=True)\n                    with zipfile.ZipFile(zip_path, 'r') as z:\n                        z.extractall(extract_target)\n                except Exception as e:\n                    log(f\"  - Unzip failed: {e}\")\n            elif s_type == 'remove':\n                location = step.get('location')\n                target = os.path.join(extract_dir, location)\n                if os.path.exists(target):\n                    log(f\"  - Removing {location}\")\n                    if os.path.isdir(target):\n                        shutil.rmtree(target)\n                    else:\n                        os.remove(target)\n\ndef install_server_jar(extract_dir, loader, mc_version):\n    if not mc_version:\n        log(\"Error: Minecraft version missing. Cannot install Server JAR.\")\n        return\n    \n    loader = loader.lower() if loader else 'vanilla'\n    \n    if mc_version.count('.') == 2 and mc_version.endswith('.11') and loader == 'fabric':\n         if mc_version == \"1.21.11\": mc_version = \"1.21.1\"\n         \n    url = f\"{API_BASE_URL}/{loader}/{mc_version}\"\n    log(f\"Querying Arelix API for {loader} {mc_version}...\")\n    try:\n        req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})\n        with urllib.request.urlopen(req, context=ctx) as r:\n            data = json.load(r)\n        if not data.get('success') or not data.get('builds'):\n            log(\"API returned no builds for this combination.\")\n            return\n        builds = data['builds']\n        builds.sort(key=lambda x: x['buildNumber'], reverse=True)\n        latest = builds[0]\n        log(f\"Found Build: {latest['name']} (Type: {latest['type']})\")\n        if latest.get('installation'):\n            process_installation_steps(latest['installation'], extract_dir)\n            log(\"Server JAR/Environment installed via installation steps.\")\n            return\n        if latest.get('jarUrl'):\n            target = os.path.join(extract_dir, 'server.jar')\n            download_file(latest['jarUrl'], target)\n            log(\"Server JAR downloaded.\")\n            return\n    except Exception as e:\n        log(f\"Server JAR installation failed: {e}\")\n\n# --- Helper Logic ---\ndef handle_overrides(extract_dir):\n    for ov_name in ['overrides', 'server-overrides']:\n        overrides_path = os.path.join(extract_dir, ov_name)\n        if os.path.exists(overrides_path) and os.path.isdir(overrides_path):\n            log(f\"Processing '{ov_name}' folder...\")\n            for root, dirs, files in os.walk(overrides_path):\n                for file in files:\n                    src = os.path.join(root, file)\n                    rel = os.path.relpath(src, overrides_path)\n                    dest = os.path.join(extract_dir, rel)\n                    os.makedirs(os.path.dirname(dest), exist_ok=True)\n                    if os.path.exists(dest):\n                        os.remove(dest)\n                    shutil.move(src, dest)\n            shutil.rmtree(overrides_path)\n            log(f\"Merged '{ov_name}' into root.\")\n\n# --- Provider Installers ---\ndef install_modrinth(extract_dir):\n    log(\"Detected Provider: Modrinth\")\n    with open(os.path.join(extract_dir, \"modrinth.index.json\"), 'r') as f:\n        data = json.load(f)\n    deps = data.get('dependencies', {})\n    mc_version = deps.get('minecraft')\n    loader = 'vanilla'\n    if 'fabric-loader' in deps: loader = 'fabric'\n    elif 'quilt-loader' in deps: loader = 'quilt'\n    elif 'forge' in deps: loader = 'forge'\n    elif 'neoforge' in deps: loader = 'neoforge'\n    log(f\"Metadata: Minecraft {mc_version}, Loader {loader}\")\n    files = data.get('files', [])\n    log(f\"Downloading {len(files)} mods/resources...\")\n    \n    skipped_client = 0\n    success_count = 0\n    \n    for f in files:\n        env = f.get('env', {})\n        if env.get('server') == 'unsupported':\n             skipped_client += 1\n             continue\n             \n        path = f.get('path')\n        downloads = f.get('downloads', [])\n        if not path or not downloads: continue\n        target = os.path.join(extract_dir, path)\n        os.makedirs(os.path.dirname(target), exist_ok=True)\n        for url in downloads:\n            if download_file(url, target):\n                success_count += 1\n                break\n                \n    log(f\"Summary: Installed {success_count} mods. Skipped {skipped_client} client-only mods.\")\n    \n    install_server_jar(extract_dir, loader, mc_version)\n    return True\n\ndef install_curseforge(extract_dir):\n    log(\"Detected Provider: CurseForge\")\n    try:\n        with open(os.path.join(extract_dir, \"manifest.json\"), 'r') as f:\n            data = json.load(f)\n    except Exception as e:\n        log(f\"Failed to read manifest.json: {e}\")\n        # Even if manifest lookup fails, we check for explicit environment variables\n        if ENV_MC_VERSION:\n            log(f\"Manifest missing, but Environment variables found. Installing Server JAR for {ENV_MC_VERSION}...\")\n            install_server_jar(extract_dir, ENV_LOADER, ENV_MC_VERSION)\n            return True\n        return False\n        \n    minecraft = data.get('minecraft', {})\n    mc_version = minecraft.get('version')\n    loaders = minecraft.get('modLoaders', [])\n    loader = 'vanilla'\n    if loaders:\n        lid = loaders[0].get('id', '').lower()\n        if 'fabric' in lid: loader = 'fabric'\n        elif 'quilt' in lid: loader = 'quilt'\n        elif 'neo' in lid: loader = 'neoforge'\n        elif 'forge' in lid: loader = 'forge'\n    log(f\"Metadata: Minecraft {mc_version}, Loader {loader}\")\n    files = data.get('files', [])\n    if not CURSEFORGE_API_KEY:\n        log(\"WARNING: CURSEFORGE_API_KEY not set/found. Cannot download mods.\")\n    else:\n        log(f\"Downloading {len(files)} mods using API Key...\")\n        headers = {'x-api-key': CURSEFORGE_API_KEY, 'Accept': 'application/json'}\n        success_count = 0\n        for cf_file in files:\n            pid = cf_file.get('projectID')\n            fid = cf_file.get('fileID')\n            try:\n                url = f\"https://api.curseforge.com/v1/mods/{pid}/files/{fid}\"\n                req = urllib.request.Request(url, headers=headers)\n                with urllib.request.urlopen(req, context=ctx) as r:\n                    fdata = json.load(r)\n                d_data = fdata.get('data', {})\n                d_url = d_data.get('downloadUrl')\n                f_name = d_data.get('fileName')\n                if d_url and f_name:\n                    target = os.path.join(extract_dir, 'mods', f_name)\n                    os.makedirs(os.path.dirname(target), exist_ok=True)\n                    if download_file(d_url, target):\n                        success_count += 1\n                else:\n                    log(f\"Skipping {pid}:{fid} - No download URL found.\")\n            except Exception as e:\n                log(f\"Failed to download {pid}:{fid} - {e}\")\n        log(f\"Downloaded {success_count}/{len(files)} mods.\")\n    install_server_jar(extract_dir, loader, mc_version)\n    return True\n\ndef install_generic(extract_dir):\n    log(\"Unknown Manifest. Assuming Generic Pack.\")\n    if ENV_MC_VERSION:\n         log(f\"Generic Pack with Environment variables. Installing Server JAR for {ENV_MC_VERSION}...\")\n         install_server_jar(extract_dir, ENV_LOADER, ENV_MC_VERSION)\n    else:\n         log(\"No Minecraft version specified in environment. Skipping Server JAR.\")\n    return True\n\ndef main():\n    log(\"Starting Smart Installer v1.1.2 (Arelix Fix)\")\n    work_dir = os.getcwd()\n    zip_name = \"modpack_download.zip\"\n    \n    global MODPACK_URL\n    if not MODPACK_URL:\n        # URL Resolution logic (omitted for brevity, assume URL is passed via ENV usually)\n        provider = os.getenv(\"MODPACK_PROVIDER\", \"\").lower()\n        mid = os.getenv(\"MODPACK_ID\", \"\")\n        vid = os.getenv(\"MODPACK_VERSION_ID\", \"\")\n        log(f\"Resolution Input: Provider={provider}, ID={mid}, Version={vid}\")\n        \n        if provider == 'modrinth' and vid:\n             # ... (Same as original)\n             pass\n        elif provider == 'curseforge' and mid and vid:\n             # ... (Same as original)\n             pass\n\n    if MODPACK_URL:\n        log(f\"Downloading Modpack from {MODPACK_URL}\")\n        if not download_file(MODPACK_URL, zip_name):\n             log(\"Failed to download modpack.\")\n             return\n    elif os.path.exists(\"modpack.zip\"):\n        zip_name = \"modpack.zip\"\n    else:\n        log(\"No pack found. Exiting.\")\n        return\n\n    log(\"Extracting modpack...\")\n    try:\n        with zipfile.ZipFile(zip_name, 'r') as z:\n            z.extractall(work_dir)\n        os.remove(zip_name)\n    except Exception as e:\n        log(f\"Extraction failed: {e}\")\n        return\n\n    if os.path.exists(\"modrinth.index.json\"):\n        install_modrinth(work_dir)\n    elif os.path.exists(\"manifest.json\"):\n        install_curseforge(work_dir)\n    else:\n        install_generic(work_dir)\n\n    handle_overrides(work_dir)\n    log(\"Installation Complete!\")\n\nif __name__ == \"__main__\":\n    main()\nPYTHON_EOF\n\n# 3. Clean files\nif [ \"${DELETE_SERVER_FILES}\" = \"true\" ]; then\n    echo \"Cleaning existing server files...\"\n    rm -rf libraries mods coremods .fabric .mixin.out server.jar user_jvm_args.txt\nfi\n\n# 4. Run Installer\necho \"Launching Smart Installer...\"\npython3 /tmp/installer.py\n\n# 5. Cleanup\nrm /tmp/installer.py",
            "container": "ghcr.io/pterodactyl/installers:debian",
            "entrypoint": "bash"
        }
    },
    "variables": [
        {
            "name": "Modpack Download URL",
            "description": "The direct download URL for the modpack ZIP file.",
            "env_variable": "MODPACK_URL",
            "default_value": "",
            "user_viewable": true,
            "user_editable": true,
            "rules": "required|url"
        },
        {
            "name": "Modpack Filename",
            "description": "The original filename of the modpack (for reference).",
            "env_variable": "MODPACK_FILENAME",
            "default_value": "",
            "user_viewable": true,
            "user_editable": true,
            "rules": "nullable|string|max:255"
        },
        {
            "name": "Modpack Provider",
            "description": "The modpack provider (modrinth, curseforge, etc.).",
            "env_variable": "MODPACK_PROVIDER",
            "default_value": "modrinth",
            "user_viewable": true,
            "user_editable": true,
            "rules": "required|string|in:modrinth,curseforge"
        },
        {
            "name": "Modpack ID",
            "description": "The unique identifier for the modpack.",
            "env_variable": "MODPACK_ID",
            "default_value": "",
            "user_viewable": true,
            "user_editable": true,
            "rules": "required|string|max:255"
        },
        {
            "name": "Modpack Name",
            "description": "The display name of the modpack.",
            "env_variable": "MODPACK_NAME",
            "default_value": "",
            "user_viewable": true,
            "user_editable": true,
            "rules": "required|string|max:255"
        },
        {
            "name": "Minecraft Version",
            "description": "The Minecraft version of the modpack.",
            "env_variable": "MINECRAFT_VERSION",
            "default_value": "",
            "user_viewable": true,
            "user_editable": false,
            "rules": "nullable|string"
        },
        {
            "name": "Modloader",
            "description": "The modloader used (forge, fabric, etc).",
            "env_variable": "MODLOADER",
            "default_value": "",
            "user_viewable": true,
            "user_editable": false,
            "rules": "nullable|string"
        }
    ]
}